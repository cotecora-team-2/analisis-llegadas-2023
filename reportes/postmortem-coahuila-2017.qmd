---
title: "Post-mortem Coahuila 2017"
execute:
  echo: false
  warning: false
format: 
  html:
    embed-resources: true
---
Teresa Ortiz, Felipe González, Michelle Anzarut

## Descripción

Consideramos los resultados del Conteo Rápido de las elecciones de gobernador de
Coahuila 2017.


- El diseño fue estratificado por distrito local.
- El tamaño de muestra seleccionado fue de alrededor de 700 casillas, que equivale
a una fracción de muestreo cercana al 20%.
- A las 2:05 am del siguiente día de la elección se presenta el último reporte
de COTECORA Coahuila, con 54.61% de la muestra recuperada (379 casillas), e
información en los 16 estratos (distritos locales):

![](reporte-2-05.png)

Los cómputos distritales para los dos candidatos punteros, sin embargo resultaron en

- Guillermo Anaya Llamas (alianza PAN) 36.40%
- Miguel Riquelme Solís (alianza PRI): 38.9%

**La tendencia anunciada por el conteo rápido fue inversa a los resultados, y 
el intervalo reportado para el candidato del PRI (con error reportado de 1.2 
puntos porcentuales) está a 1.6 puntos porcentuales del valor de cómputos distritales**.

En este reporte buscamos explicar esta discrepancia. Dado el diseño, utilizaremos
el estimador de razón combinado.

```{r}
#| code-fold: true
#| message: false
#| warning: false
library(tidyverse)
library(quickcountmx)
library(DiagrammeR)
source("../R/crear-tablas-alianzas.R")
# remotes::install_github("cotecora-team-2/quickcountmx",
#                        # ref = "code-improvements")


```



```{r}

coah_muestra_tbl <- read_csv("../datos/Coah_muestra_31052017.csv")
coah_remesa_tbl <- read_csv("../datos/COA_INFORMACION_DE_CASILLAS_REPORTADAS_Y_RELACION_DE_CASILLAS_INTEGRADAS_AL_CALCULO_FINAL.csv") |> 
  mutate(fecha_hora = lubridate::mdy_hm(`FECHA Y HORA DE REPORTE`)) |> 
  arrange(fecha_hora) |> 
  mutate(casillas_rep = row_number()) |> 
  rename(LISTA_NOMINAL = `LISTA NOMINAL`) |> 
  mutate(cand_pri = PRI + PVEM + PNA + PSDI + PRC + PCP + PJ + COAL1,
         cand_pan = PAN + PUDC + PES + PPC + COAL2,
         cand_3 = MORENA,
         cand_4 = `GUERRERO GARCIA JAVIER`,
         cand_5 = PRD,
         cand_6 = PT,
         cand_7 = `SALINAS VALDEZ LUIS HORACIO`,
         otros = `CANDIDATO INDEPENDIENTE 1` + `VOTOS CNR` + `VOTOS NULOS`) |> 
  mutate(total = cand_pri + cand_pan + cand_3 + cand_4 + cand_5 + cand_6 + cand_7 + otros) |> 
  mutate(DISTRITO = as.character(DISTRITO)) |> 
  mutate(horas = difftime(fecha_hora, min(fecha_hora), units = "hours")) |> 
  mutate(horas = as.numeric(horas))
```

## Tiempos de llegada de casillas

Las tasas de llegada fueron en general bajas (menos de 15% de la muestra por hora
en los momentos relativamente rápidos), y después de las 11pm la tasa
fue bajando considerablemente:

```{r}
ggplot(coah_remesa_tbl, aes(x = horas, y = casillas_rep / nrow(coah_muestra_tbl))) +
  geom_line() + geom_vline(xintercept = 7, colour = "red") +
  xlab("Horas después de las 7pm") + ylab("Proporción de muestra recibida") +
  annotate("text", x= 6.8, y = 0.1, label = "Último reporte", colour = "red",
           angle = 90)
```

```{r}
coah_muestra_tbl <- coah_muestra_tbl |>
  rename(ID_DISTRITO_LOCAL = DIST_LOC ) |> 
  left_join(coah_tidy |> mutate(CASILLA = ifelse(CASILLA %in% c("C10", "C20"), 
                          CASILLA, str_remove(CASILLA, "0"))))
```


```{r}
coah_muestra_tbl <- coah_muestra_tbl |> left_join(coah_remesa_tbl |> dplyr::select(FOLIO, horas))
```

## Muestra completa vs remesa

```{r}
# Remesa con Cómputos
estratos_coah_tbl <- coah |> count(ID_DISTRITO_LOCAL) |> 
  mutate(ID_DISTRITO_LOCAL = as.character(ID_DISTRITO_LOCAL))
coah_muestra_tbl <- mutate(coah_muestra_tbl, ID_DISTRITO_LOCAL = as.character(ID_DISTRITO_LOCAL))
coah_remesa_2_tbl <- coah_remesa_tbl |> 
  filter(fecha_hora < lubridate::ymd_hm("2017-06-05 02:06"))
est_remesa_coah_tbl <- ratio_estimation(coah_muestra_tbl |> 
  filter(!is.na(horas), !is.na(cand_pan)) |> 
  filter(FOLIO %in% coah_remesa_2_tbl$FOLIO), 
  ID_DISTRITO_LOCAL, 
  estratos_coah_tbl, n_stratum = n, parties = c(cand_pri:otros, MORENA, PRD, PT)) |> 
  mutate(tipo = "remesa (cómputos)")
#est_remesa_coah_tbl
```
```{r}
# Remesa con datos recibidos
#estratos_coah_tbl <- coah |> count(ID_DISTRITO_LOCAL) |> 
#  mutate(ID_DISTRITO_LOCAL = as.character(ID_DISTRITO_LOCAL))
#coah_muestra_tbl <- mutate(coah_muestra_tbl, ID_DISTRITO_LOCAL = as.character(ID_DISTRITO_LOCAL))
est_remesa_original_coah_tbl <- ratio_estimation(coah_remesa_tbl |> 
    filter(!is.na(horas)) |> 
    mutate(ID_DISTRITO_LOCAL = DISTRITO) |> 
    filter(fecha_hora < lubridate::ymd_hm("2017-06-05 02:06"))
    , 
  ID_DISTRITO_LOCAL, 
  estratos_coah_tbl, n_stratum = n, parties = cand_pri:otros) |> 
  mutate(tipo = "remesa (recibida)") 
#est_remesa_coah_tbl
#est_remesa_original_coah_tbl
```


```{r}
# Muestra completa con cómputos
est_muestra_coah_tbl <- ratio_estimation(coah_muestra_tbl |> filter(!is.na(cand_pan)), ID_DISTRITO_LOCAL, 
  estratos_coah_tbl, n_stratum = n, parties = c(cand_pri:otros, MORENA, PRD, PT)) |> 
  mutate(tipo = "muestra (cómputos)")
#est_muestra_coah_tbl
```

A continuación presentamos nuestras propias estimaciones, considerando la remesa
de último reporte y muestra completa con cómputos distritales:


```{r}
#| fig.width: 8
#| fig.height: 3
res <- tibble(party = c("cand_pri", "cand_pan", "cand_morena", "cand_4"),
              prop_obs = c(38.90, 36.40, 11.91, 8.31)) |>
  filter(party!="cand_morena")
# est_conteo_tbl <- tibble(party = c("cand_pri", "cand_pan"),
#                      prop = c(36.051, 37.8659), 
#                      std_error = c(0.0129, 0.0122) * 100 / 2, 
#                      tipo = "remesa (recibida)", color = "cotecora 2017")
# separate ratio con survey: pri 36.7, pan 37.7        
bind_rows(est_muestra_coah_tbl, est_remesa_coah_tbl, est_remesa_original_coah_tbl) |> 
  add_column(color = "est. propia") |> 
  # bind_rows(est_conteo_tbl) |> 
  filter(party %in% c("cand_pri", "cand_pan", "MORENA")) |> 
  mutate(party = ifelse(party=="MORENA", "cand_morena", party)) |> 
  filter(party!="cand_morena") |>
  ggplot() +
  geom_pointrange(aes(x = party, y = prop, ymin = prop - 2 * std_error,
                      ymax = prop + 2 * std_error,  color = color), 
                  position = position_dodge2(width = 0.1), fatten = 0.9, 
                  show.legend = FALSE) + 
  geom_point(data = res |> filter(prop_obs > 10), 
             aes(x = party, y = prop_obs), 
             colour = "red", size = 3) +
  # geom_pointrange(data = est_conteo_tbl, aes(x = party, y = prop, ymin = prop - 2 * std_error,
  #                     ymax = prop + 2 * std_error), color = "darkgray") +
  facet_wrap(~ tipo) + 
  scale_color_manual("", values = c("est.propia" = "black", "cotecora 2017" = "salmon"))
```
- Para la remesa recibida, nuestros intervalos fallan de igual manera que los reportados
 por COTECORA Coahuila, aunque los nuestros son algo más angostos. Esto puede ser por el tipo particular de estimador que se haya
utilizado. 
- La diferencia entre cómputos y datos recibidos no es causante de la discrepancia
grande, aunque hay una ligera diferencia entre las estimaciones con remesa recibida y remesa
usando cómputos distritales. 
- La muestra completa hubiera dado la respuesta correcta, mientras
que la remesa es inconcluyente con la tendencia incorrecta.
- El sesgo observado en la remesa con respecto a la muestra completa es 
aproximadamente del mismo tamaño que el error de estimación (un poco más
de un punto porcentual).


## Tendencia de las estimaciones

Consideramos también cómo se ve la tendencia en el tiempo de las estimaciones:

```{r}
#| fig.width: 6
#| fig.height: 4
remesa_final <- coah_remesa_tbl |> 
    filter(!is.na(horas)) |> 
    mutate(ID_DISTRITO_LOCAL = DISTRITO) |> 
    filter(fecha_hora < lubridate::ymd_hm("2017-06-05 02:06")) 

cortes <- unique(remesa_final$fecha_hora)
cortes <- cortes[-1]
est_cortes <- map_df(set_names(cortes), function(corte){
  remesa_final |> 
    filter(fecha_hora <= corte) |> 
    ratio_estimation(stratum = ID_DISTRITO_LOCAL, estratos_coah_tbl, 
                 n_stratum = n, parties = cand_pri:otros, std_errors = FALSE) |> 
    filter(party %in% c("cand_pri", "cand_pan"))
}, .id = "fecha_hora")
est_cortes |> 
  mutate(fecha_hora = lubridate::ymd_hms(fecha_hora)) |> 
  ggplot(aes(x = fecha_hora, y = prop, color = party)) +
    geom_line() +
  labs(title = "Estimaciones por remesa", color = "")

```



## Explicación de censura por tiempo

El sesgo no proviene de fallas en el
método de estimación (es decir, sesgo por muestra chica
en el estimador de razón, etc.), ni de discrepancias entre cómputos y remesas. El sesgo
proviene de la influencia en 
la selección de la remesa por tiempo. 

Los diagramas de abajo describen el escenario de muestra completa (izquierda) y 
un escenario donde el patrón de faltantes está influenciado por el patrón de votos 
observado en las casillas (derecha) lo que rompe la aleatoriedad de la muestra
recibida:


```{r}
#| code-fold: true
grViz('
digraph {
  subgraph completo {
    graph [ranksep = 0.2]
    node [shape=circle]
    node [shape=plaintext]
    
    Votos_1 [label = "Votos"]
    Z_1 [label="Z"]
    S_1 [label="S",fontcolor = "red"]
    Estrato_1 [label="Estrato"]
    edge [minlen = 3]
    Z_1 -> S_1
    Estrato_1 -> S_1
    Estrato_1 -> Votos_1
  }
  label = "Muestra completa vs muestra censurada"
  


 subgraph con_tiempo {
  graph [ranksep = 0.2]
    node [shape=circle]
    Dif
    U
    node [shape=plaintext]
    Votos
    S [fontcolor = "red"]
    edge [minlen = 3]
    Z -> S
    Estrato -> S
    Estrato -> Votos
    Votos -> Dif [color="gray"]
    Dif -> TiempoLlegada
    U -> TiempoLlegada
    TiempoLlegada -> S
{rank=same; Estrato;Votos;Dif}
  
 }
}
')
```
* En el caso de muestra completa, condicinando a estrato, el proceso de selección 
(Z $\to$ S) es independiente de votos.

* En el caso de muestra censurada, aún condicionando a estrato, los votos están
correlacionados con la muestra observada a través del tiempo de llegada \
(Votos $\to$ Dif $\to$ TiempoLlegada $\to$ S).

* Los factores U que influyen en el tiempo de llegada y que no están relacionados
al patrón de votos no rompen la aleatoriedad de la muestra.



```{r}
orden_DL <- coah_remesa_tbl |> 
  group_split(DISTRITO, .keep = TRUE) |> 
  map_df(~lm(data = ., "horas ~ cand_pri")$coefficients[2]) |> 
  add_column(DISTRITO = sort(unique(coah_remesa_tbl$DISTRITO))) |> 
  arrange(cand_pri) |> 
  pull(DISTRITO)
coah_remesa_tbl |> 
  mutate(DISTRITO = factor(as.character(DISTRITO), levels = orden_DL[16:1])) |> 
ggplot(aes(x = cand_pri, y = horas, group = DISTRITO)) + 
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm", se = FALSE) + 
  facet_wrap(~DISTRITO,  nrow = 3) 
```
* En la mayor parte de los distritos observamos una relación positiva entre el número de votos por el candidato del PRI y la hora de llegada de la casilla a la muestra. Nuestra hipótesis es que esto se debe al gran número de combinaciones posibles que había para votar por dicho candidato.  


## Resumen

* No hay razón para pensar que muestras más grandes resuelven el problema del 
sesgo si el porcentaje de casillas observadas es relativamente bajo (por ejemplo, menor  que 70%). No se puede **garantizar** que en una nueva elección el sesgo será ignorable.

* Con muestras relativamente grandes, como la que se seleccionó en este conteo, 
si el porcentaje de casillas es bajo los errores de estimación reportados están gravemente
sesgados hacia abajo. En este ejemplo particular el sesgo es mayor que el error reportado.

* Sí hay razones por las que muestras más grandes pueden producir retrasos adicionales
y menor calidad de datos (presión a CAEs, seguimiento de reportes).
